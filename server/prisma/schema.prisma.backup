generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id             String   @id @default(cuid())
  email          String   @unique
  passwordHash   String?
  role           UserRole @default(CANDIDATE)
  profile        Json?
  candidateProfile   CandidateProfile?
  interviewerProfile InterviewerProfile?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

enum UserRole {
  CANDIDATE
  INTERVIEWER
  ADMIN
}

enum MatchStatus {
  QUEUED
  MATCHED
  SCHEDULED
  COMPLETED
  CANCELLED
  EXPIRED
}

enum SessionFormat {
  SYSTEM_DESIGN
  CODING
  BEHAVIORAL
  MIXED
}

model CandidateProfile {
  id                 String         @id @default(cuid())
  userId             String         @unique
  user               User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  displayName        String
  timezone           String
  experienceYears    Int
  preferredRoles     String[]
  preferredLanguages String[]
  focusAreas         String[]
  bio                String?
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  matchRequests      MatchRequest[]
}

model InterviewerProfile {
  id               String                  @id @default(cuid())
  userId           String                  @unique
  user             User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  displayName      String
  timezone         String
  experienceYears  Int
  languages        String[]
  specializations  String[]
  bio              String?
  rating           Float                   @default(0)
  createdAt        DateTime                @default(now())
  updatedAt        DateTime                @updatedAt
  availability     InterviewerAvailability[]
  matches          InterviewMatch[]
}

model InterviewerAvailability {
  id             String             @id @default(cuid())
  interviewerId  String
  interviewer    InterviewerProfile @relation(fields: [interviewerId], references: [id], onDelete: Cascade)
  start          DateTime
  end            DateTime
  isRecurring    Boolean            @default(false)
  createdAt      DateTime           @default(now())
}

model MatchRequest {
  id                 String         @id @default(cuid())
  candidateId        String
  candidate          CandidateProfile @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  targetRole         String
  focusAreas         String[]
  preferredLanguages String[]
  sessionFormat      SessionFormat
  notes              String?
  status             MatchStatus    @default(QUEUED)
  matchedAt          DateTime?
  expiresAt          DateTime?
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  result             InterviewMatch?
}

model InterviewMatch {
  id             String             @id @default(cuid())
  requestId      String             @unique
  request        MatchRequest       @relation(fields: [requestId], references: [id], onDelete: Cascade)
  interviewerId  String
  interviewer    InterviewerProfile @relation(fields: [interviewerId], references: [id], onDelete: Cascade)
  effectivenessScore Int            @default(0)
  scheduledAt    DateTime?
  roomUrl        String?
  status         MatchStatus        @default(MATCHED)
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
}
