generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String              @id @default(cuid())
  email              String              @unique
  passwordHash       String?
  role               UserRole            @default(CANDIDATE)
  profile            Json?
  candidateProfile   CandidateProfile?
  interviewerProfile InterviewerProfile?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
}

enum UserRole {
  CANDIDATE
  INTERVIEWER
  ADMIN
}

enum MatchStatus {
  QUEUED
  MATCHED
  SCHEDULED
  COMPLETED
  CANCELLED
  EXPIRED
}

enum SessionFormat {
  SYSTEM_DESIGN
  CODING
  BEHAVIORAL
  MIXED
}

enum SlotParticipantRole {
  CANDIDATE
  INTERVIEWER
  OBSERVER
}

model CandidateProfile {
  id                 String            @id @default(cuid())
  userId             String            @unique
  user               User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  displayName        String
  timezone           String
  experienceYears    Int
  preferredRoles     String[]
  preferredLanguages String[]
  focusAreas         String[]
  bio                String?
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  matchRequests      MatchRequest[]
  slotParticipants   SlotParticipant[] @relation("SlotParticipantCandidate")
}

model InterviewerProfile {
  id               String                    @id @default(cuid())
  userId           String                    @unique
  user             User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  displayName      String
  timezone         String
  experienceYears  Int
  languages        String[]
  specializations  String[]
  bio              String?
  rating           Float                     @default(0)
  createdAt        DateTime                  @default(now())
  updatedAt        DateTime                  @updatedAt
  availability     InterviewerAvailability[]
  hostedSlots      InterviewerAvailability[] @relation("AvailabilityHost")
  slotParticipants SlotParticipant[]         @relation("SlotParticipantInterviewer")
  matches          InterviewMatch[]
}

model InterviewerAvailability {
  id            String              @id @default(cuid())
  interviewerId String
  interviewer   InterviewerProfile  @relation(fields: [interviewerId], references: [id], onDelete: Cascade)
  hostId        String?
  host          InterviewerProfile? @relation("AvailabilityHost", fields: [hostId], references: [id], onDelete: SetNull)
  hostName      String?
  capacity      Int                 @default(1)
  start         DateTime
  end           DateTime
  isRecurring   Boolean             @default(false)
  createdAt     DateTime            @default(now())
  participants  SlotParticipant[]
}

model SlotParticipant {
  id               String                  @id @default(cuid())
  slotId           String
  slot             InterviewerAvailability @relation(fields: [slotId], references: [id], onDelete: Cascade)
  role             SlotParticipantRole
  candidateId      String?
  candidate        CandidateProfile?       @relation("SlotParticipantCandidate", fields: [candidateId], references: [id], onDelete: Cascade)
  interviewerId    String?
  interviewer      InterviewerProfile?     @relation("SlotParticipantInterviewer", fields: [interviewerId], references: [id], onDelete: Cascade)
  waitlistPosition Int?
  createdAt        DateTime                @default(now())

  @@unique([slotId, candidateId])
  @@unique([slotId, interviewerId])
  @@index([slotId, waitlistPosition])
}

model MatchRequest {
  id                 String           @id @default(cuid())
  candidateId        String
  candidate          CandidateProfile @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  targetRole         String
  focusAreas         String[]
  preferredLanguages String[]
  sessionFormat      SessionFormat
  notes              String?
  status             MatchStatus      @default(QUEUED)
  matchedAt          DateTime?
  expiresAt          DateTime?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  result             InterviewMatch?
}

model InterviewMatch {
  id                 String             @id @default(cuid())
  requestId          String             @unique
  request            MatchRequest       @relation(fields: [requestId], references: [id], onDelete: Cascade)
  interviewerId      String
  interviewer        InterviewerProfile @relation(fields: [interviewerId], references: [id], onDelete: Cascade)
  effectivenessScore Int                @default(0)
  scheduledAt        DateTime?
  roomUrl            String?
  roomId             String?
  roomToken          String?
  status             MatchStatus        @default(MATCHED)
  completedAt        DateTime?
  summary            InterviewSummary?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
}

model InterviewSummary {
  id               String         @id @default(cuid())
  matchId          String         @unique
  match            InterviewMatch @relation(fields: [matchId], references: [id], onDelete: Cascade)
  interviewerNotes String
  candidateNotes   String?
  aiHighlights     Json?
  rating           Int            @default(0)
  strengths        String[]       @default([])
  improvements     String[]       @default([])
  createdAt        DateTime       @default(now())
}
